{"version":3,"sources":["file:///E:/xisle-dev/xisle/hugo-site/themes/xisle/assets/js/carousel.js"],"sourcesContent":["document.addEventListener('DOMContentLoaded', () =\u003e {\r\n    // ... (Your existing console.logs for initial script loading) ...\r\n\r\n    const carouselContainers = document.querySelectorAll('.carousel-container');\r\n    // ... (Your existing console.log for containers found) ...\r\n\r\n    carouselContainers.forEach(container =\u003e {\r\n        // ... (Your existing console.logs for elements found inside container) ...\r\n\r\n        const carouselTrack = container.querySelector('.carousel-track');\r\n        // ... (null checks and initial logs for track, slides, buttons, dots) ...\r\n\r\n        let slides = Array.from(container.querySelectorAll('.carousel-slide'));\r\n        let prevBtn = container.querySelector('.carousel-prev-btn');\r\n        let nextBtn = container.querySelector('.carousel-next-btn');\r\n        let dotsContainer = container.querySelector('.carousel-dots');\r\n        let dots = dotsContainer ? Array.from(dotsContainer.querySelectorAll('.dot')) : [];\r\n\r\n\r\n        let currentIndex = 0;\r\n        let slideWidth = 0;\r\n        if (slides.length \u003e 0) {\r\n             slideWidth = slides[0].offsetWidth;\r\n        }\r\n        // ... (initial slideWidth logs) ...\r\n\r\n        window.addEventListener('resize', () =\u003e {\r\n            slideWidth = slides[0] ? slides[0].offsetWidth : 0;\r\n            // IMPORTANT: If you resize during a drag animation, stop it\r\n            cancelAnimationFrame(animationID);\r\n            isDragging = false; // Reset drag state\r\n            updateCarousel();\r\n        });\r\n\r\n        // --- Core Carousel Update Function ---\r\n        function updateCarousel() {\r\n            console.log('updateCarousel called. Current index:', currentIndex);\r\n            if (slides.length === 0) {\r\n                console.warn('No slides to update. Exiting updateCarousel.');\r\n                return;\r\n            }\r\n\r\n            const containerWidth = container.offsetWidth;\r\n            const activeSlide = slides[currentIndex];\r\n\r\n            if (!activeSlide) {\r\n                console.error(\"Active slide not found for index:\", currentIndex, \"in updateCarousel.\");\r\n                return;\r\n            }\r\n\r\n            const activeSlideRect = activeSlide.getBoundingClientRect();\r\n            const currentSlideRelativeLeft = activeSlide.offsetLeft;\r\n            const desiredActiveSlideLeftInView = (containerWidth / 2) - (activeSlideRect.width / 2);\r\n\r\n            let targetOffset = -(currentSlideRelativeLeft - desiredActiveSlideLeftInView);\r\n\r\n            const trackWidth = carouselTrack.scrollWidth;\r\n            const maxScroll = trackWidth - containerWidth;\r\n            targetOffset = Math.max(-maxScroll, Math.min(0, targetOffset));\r\n\r\n            // ALWAYS enable transition for programmatic moves (arrows, dots, snap)\r\n            carouselTrack.style.transition = 'transform 0.5s ease-in-out';\r\n            carouselTrack.style.transform = `translateX(${targetOffset}px)`;\r\n            console.log('  Track transform set to:', carouselTrack.style.transform);\r\n\r\n            slides.forEach((slide, index) =\u003e {\r\n                slide.classList.remove('active');\r\n            });\r\n            slides[currentIndex].classList.add('active');\r\n            // ... (active dot updates) ...\r\n            dots.forEach((dot, index) =\u003e {\r\n                dot.classList.remove('active');\r\n            });\r\n            if (dots[currentIndex]) {\r\n                dots[currentIndex].classList.add('active');\r\n            }\r\n        }\r\n\r\n        // --- Navigation Functions (goToSlide, etc. - UNCHANGED) ---\r\n        function goToSlide(index) {\r\n            console.log('goToSlide called with index:', index);\r\n            if (index \u003c 0 || index \u003e= slides.length) {\r\n                console.warn(\"Attempted to go to an invalid slide index:\", index);\r\n                return;\r\n            }\r\n            currentIndex = index;\r\n            updateCarousel();\r\n        }\r\n\r\n        // --- Event Listeners for Buttons and Dots (UNCHANGED) ---\r\n        if (prevBtn) { prevBtn.addEventListener('click', () =\u003e { console.log('Prev button clicked.'); goToSlide((currentIndex === 0) ? slides.length - 1 : currentIndex - 1); }); }\r\n        if (nextBtn) { nextBtn.addEventListener('click', () =\u003e { console.log('Next button clicked.'); goToSlide((currentIndex === slides.length - 1) ? 0 : currentIndex + 1); }); }\r\n        if (dots.length \u003e 0) {\r\n            dots.forEach(dot =\u003e {\r\n                dot.addEventListener('click', (e) =\u003e {\r\n                    console.log('Dot clicked. Data index:', e.target.dataset.index);\r\n                    const index = parseInt(e.target.dataset.index);\r\n                    goToSlide(index);\r\n                });\r\n            });\r\n        }\r\n        if (slides.length \u003e 0) {\r\n            slides.forEach(slide =\u003e {\r\n                slide.addEventListener('click', () =\u003e {\r\n                    const clickedIndex = parseInt(slide.dataset.index);\r\n                    console.log('Slide clicked! Data index:', clickedIndex);\r\n                    goToSlide(clickedIndex);\r\n                });\r\n            });\r\n        }\r\n\r\n        // --- DRAG / MOUSE SCROLL FUNCTIONALITY ---\r\n        let isDragging = false;\r\n        let startPos = 0;\r\n        let currentTranslate = 0;\r\n        let prevTranslate = 0;\r\n        let animationID = 0;\r\n        let velocity = 0;\r\n        let lastPosition = 0;\r\n        let lastTime = 0;\r\n        const friction = 0.99; // Adjust: Higher = slower deceleration. Try 0.94-0.98\r\n        const minVelocity = 0.1; // Reduced this, as it might be stopping too early. Try 0.1-0.5\r\n\r\n\r\n        // Helper to get current transform X value\r\n        function getTranslateX(element) {\r\n            const style = window.getComputedStyle(element);\r\n            const matrix = new DOMMatrixReadOnly(style.transform);\r\n            return matrix.m41;\r\n        }\r\n\r\n        function touchStart(event) {\r\n            console.log('Drag started');\r\n            carouselTrack.style.transition = 'none'; // CRUCIAL: Disable CSS transition\r\n            isDragging = true;\r\n            startPos = event.type.includes('mouse') ? event.pageX : event.touches[0].clientX;\r\n            prevTranslate = getTranslateX(carouselTrack);\r\n            lastPosition = startPos;\r\n            lastTime = Date.now();\r\n            velocity = 0;\r\n            cancelAnimationFrame(animationID); // Stop any ongoing animation\r\n        }\r\n\r\n        function touchMove(event) {\r\n            if (!isDragging) return;\r\n            event.preventDefault(); // Prevent default browser scroll/drag\r\n            // If dragging, prevent click events from firing (for image clicks after drag)\r\n            container.classList.add('is-dragging'); // Add class to manage drag state (can also be for cursor style)\r\n\r\n\r\n            const currentPosition = event.type.includes('mouse') ? event.pageX : event.touches[0].clientX;\r\n            const currentTime = Date.now();\r\n            const deltaX = currentPosition - startPos;\r\n            currentTranslate = prevTranslate + deltaX;\r\n\r\n            const moveDelta = currentPosition - lastPosition;\r\n            const timeDelta = currentTime - lastTime;\r\n            if (timeDelta \u003e 0) {\r\n                 velocity = moveDelta / timeDelta; // Pixels per millisecond\r\n            }\r\n\r\n            lastPosition = currentPosition;\r\n            lastTime = currentTime;\r\n\r\n            const trackWidth = carouselTrack.scrollWidth;\r\n            const containerWidth = container.offsetWidth;\r\n            const maxTranslateX = 0;\r\n            const minTranslateX = containerWidth - trackWidth;\r\n\r\n            // Apply a \"pull-back\" effect if dragging past ends\r\n            if (currentTranslate \u003e maxTranslateX + 50) {\r\n                currentTranslate = maxTranslateX + 50 + (currentTranslate - (maxTranslateX + 50)) * 0.1;\r\n            } else if (currentTranslate \u003c minTranslateX - 50) {\r\n                currentTranslate = minTranslateX - 50 + (currentTranslate - (minTranslateX - 50)) * 0.1;\r\n            }\r\n\r\n            carouselTrack.style.transform = `translateX(${currentTranslate}px)`;\r\n        }\r\n\r\n        function touchEnd(event) {\r\n            console.log('Drag ended. Final velocity:', velocity);\r\n            isDragging = false;\r\n            // Remove the is-dragging class\r\n            setTimeout(() =\u003e { // Small timeout to allow potential click event to be suppressed\r\n                container.classList.remove('is-dragging');\r\n            }, 50);\r\n\r\n\r\n            const trackWidth = carouselTrack.scrollWidth;\r\n            const containerWidth = container.offsetWidth;\r\n            const maxTranslateX = 0;\r\n            const minTranslateX = containerWidth - trackWidth;\r\n\r\n            // Handle immediate snap if overshot\r\n            if (currentTranslate \u003e maxTranslateX) {\r\n                currentTranslate = maxTranslateX;\r\n                velocity = 0;\r\n                carouselTrack.style.transition = 'transform 0.3s ease-out'; // Smooth snap back\r\n                carouselTrack.style.transform = `translateX(${currentTranslate}px)`;\r\n                snapToNearestSlide();\r\n                return;\r\n            } else if (currentTranslate \u003c minTranslateX) {\r\n                currentTranslate = minTranslateX;\r\n                velocity = 0;\r\n                carouselTrack.style.transition = 'transform 0.3s ease-out'; // Smooth snap back\r\n                carouselTrack.style.transform = `translateX(${currentTranslate}px)`;\r\n                snapToNearestSlide();\r\n                return;\r\n            }\r\n\r\n            // If within bounds, start deceleration\r\n            if (Math.abs(velocity) \u003e minVelocity) {\r\n                animationID = requestAnimationFrame(animation);\r\n            } else {\r\n                snapToNearestSlide(); // If very slow, just snap\r\n            }\r\n        }\r\n\r\n        function animation() {\r\n            if (isDragging) {\r\n                cancelAnimationFrame(animationID); // Ensure it stops if drag starts during animation\r\n                return;\r\n            }\r\n\r\n            currentTranslate += velocity * 16.66; // Pixels per frame (velocity is px/ms, 16.66ms/frame)\r\n            velocity *= friction; // Apply friction\r\n\r\n            const trackWidth = carouselTrack.scrollWidth;\r\n            const containerWidth = container.offsetWidth;\r\n            const maxTranslateX = 0;\r\n            const minTranslateX = containerWidth - trackWidth;\r\n\r\n            // Constrain during deceleration\r\n            if (currentTranslate \u003e maxTranslateX) {\r\n                currentTranslate = maxTranslateX;\r\n                velocity = 0; // Stop\r\n            }\r\n            if (currentTranslate \u003c minTranslateX) {\r\n                currentTranslate = minTranslateX;\r\n                velocity = 0; // Stop\r\n            }\r\n\r\n            // Stop animation if velocity is too low or we hit boundaries\r\n            if (Math.abs(velocity) \u003c minVelocity) {\r\n                cancelAnimationFrame(animationID);\r\n                snapToNearestSlide();\r\n                return;\r\n            }\r\n\r\n            // CRUCIAL: Ensure transition is 'none' during deceleration\r\n            carouselTrack.style.transition = 'none';\r\n            carouselTrack.style.transform = `translateX(${currentTranslate}px)`;\r\n            animationID = requestAnimationFrame(animation);\r\n        }\r\n\r\n        function snapToNearestSlide() {\r\n            console.log('Snapping to nearest slide...');\r\n            // This function will eventually call updateCarousel, which enables transition\r\n            // So we don't need to enable transition here immediately\r\n            // carouselTrack.style.transition = 'transform 0.3s ease-out'; // This was potentially conflicting\r\n\r\n            const currentTrackTranslateX = getTranslateX(carouselTrack);\r\n\r\n            let closestIndex = currentIndex;\r\n            let minDiff = Infinity;\r\n\r\n            slides.forEach((slide, index) =\u003e {\r\n                const slideRect = slide.getBoundingClientRect();\r\n                const containerRect = container.getBoundingClientRect(); // Get container's rect for consistent center\r\n\r\n                const slideCenterRelativeToTrack = slide.offsetLeft + (slideRect.width / 2);\r\n\r\n                const desiredTranslateX = (containerRect.width / 2) - slideCenterRelativeToTrack;\r\n\r\n                const diff = Math.abs(currentTrackTranslateX - desiredTranslateX);\r\n\r\n                if (diff \u003c minDiff) {\r\n                    minDiff = diff;\r\n                    closestIndex = index;\r\n                }\r\n            });\r\n\r\n            if (closestIndex !== currentIndex) {\r\n                goToSlide(closestIndex);\r\n            } else {\r\n                 updateCarousel(); // Re-center current slide, will apply transition\r\n            }\r\n        }\r\n\r\n\r\n        // Attach Mouse and Touch listeners\r\n        carouselTrack.addEventListener('mousedown', touchStart);\r\n        document.addEventListener('mouseup', touchEnd); // Listen on document\r\n        carouselTrack.addEventListener('mouseleave', (event) =\u003e {\r\n            if (isDragging) touchEnd(event);\r\n        });\r\n        carouselTrack.addEventListener('mousemove', touchMove);\r\n\r\n        carouselTrack.addEventListener('touchstart', touchStart);\r\n        carouselTrack.addEventListener('touchend', touchEnd);\r\n        carouselTrack.addEventListener('touchcancel', touchEnd);\r\n        carouselTrack.addEventListener('touchmove', touchMove);\r\n\r\n        // Prevent dragging images from starting native drag behavior / prevent clicks immediately after drag\r\n        slides.forEach(slide =\u003e {\r\n            const img = slide.querySelector('img');\r\n            if (img) img.ondragstart = () =\u003e false;\r\n            // Prevent click event on slide if it was a drag\r\n            slide.addEventListener('click', (e) =\u003e {\r\n                // If a drag just happened (checked via a class), prevent click\r\n                if (container.classList.contains('is-dragging')) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation(); // Stop propagation to prevent parent clicks\r\n                } else {\r\n                    const clickedIndex = parseInt(slide.dataset.index);\r\n                    console.log('Slide clicked! Data index:', clickedIndex);\r\n                    goToSlide(clickedIndex);\r\n                }\r\n            }, true); // Use capture phase for the click event\r\n        });\r\n\r\n\r\n        // Initial carousel update\r\n        updateCarousel();\r\n    });\r\n});"],"mappings":"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","names":[]}